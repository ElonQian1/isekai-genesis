import React, { useEffect, useCallback, useState, useRef } from 'react';
import { Socket } from 'socket.io-client';
import {
  GameMap,
  TileType,
  TILE_VISUALS,
  Position,
  Direction,
  DIRECTION_DELTA,
  MapNPC,
  WorldPlayer,
} from '@card-game/shared';
import '../styles/pixel.css';
import '../styles/world.css';

// ç§èŠæ¶ˆæ¯ç±»å‹
interface ChatMessage {
  type: 'sent' | 'received';
  senderName: string;
  receiverName?: string;
  message: string;
  timestamp: Date;
}

// ç»„é˜Ÿé‚€è¯·ç±»å‹
interface PendingInvite {
  inviteId: string;
  inviterName: string;
}

// ç¤ºä¾‹åœ°å›¾æ•°æ® - é¿éš¾æ‰€å¤§å…
const SHELTER_MAP: GameMap = {
  id: 'shelter_main',
  name: 'é¿éš¾æ‰€ - ä¸­å¤®å¤§å…',
  width: 20,
  height: 15,
  spawnPoint: { x: 10, y: 12 },
  tiles: generateShelterMap(),
  portals: [
    {
      id: 'portal_battle',
      position: { x: 10, y: 2 },
      targetMapId: 'battle_area',
      targetPosition: { x: 5, y: 10 },
      name: 'æˆ˜æ–—åŒºåŸŸ',
    },
  ],
  npcs: [
    {
      id: 'npc_commander',
      name: 'æŒ‡æŒ¥å®˜',
      position: { x: 5, y: 5 },
      sprite: 'ğŸ‘¨â€âœˆï¸',
      dialogues: ['æ¬¢è¿æ¥åˆ°é¿éš¾æ‰€ï¼Œå¹¸å­˜è€…ã€‚', 'è¿™é‡Œæ˜¯äººç±»æœ€åçš„å ¡å’ã€‚'],
      type: 'quest',
    },
    {
      id: 'npc_merchant',
      name: 'å•†äºº',
      position: { x: 15, y: 5 },
      sprite: 'ğŸ§™',
      dialogues: ['éœ€è¦è£…å¤‡å—ï¼Ÿçœ‹çœ‹æˆ‘çš„è´§ç‰©å§ã€‚'],
      type: 'shop',
    },
  ],
  monsters: [
    {
      id: 'boss_titan',
      name: 'æ·±æ¸Šæ³°å¦',
      position: { x: 10, y: 3 },
      sprite: 'ğŸ‰',
      level: 99,
      isBoss: true,
      bossId: 'abyssal_titan',
    },
    {
      id: 'monster_zombie',
      name: 'å˜å¼‚ä¸§å°¸',
      position: { x: 4, y: 8 },
      sprite: 'ğŸ§Ÿ',
      level: 15,
      isBoss: false,
    },
    {
      id: 'monster_spider',
      name: 'å‰§æ¯’èœ˜è››',
      position: { x: 16, y: 10 },
      sprite: 'ğŸ•·ï¸',
      level: 12,
      isBoss: false,
    },
  ],
};

// ç”Ÿæˆé¿éš¾æ‰€åœ°å›¾
function generateShelterMap(): GameMap['tiles'] {
  const tiles: GameMap['tiles'] = [];
  
  for (let y = 0; y < 15; y++) {
    tiles[y] = [];
    for (let x = 0; x < 20; x++) {
      // è¾¹ç•Œå¢™å£
      if (x === 0 || x === 19 || y === 0 || y === 14) {
        tiles[y][x] = { type: TileType.WALL, walkable: false };
      }
      // ä¸­å¤®å»ºç­‘åŒºåŸŸ
      else if (y >= 1 && y <= 3 && x >= 8 && x <= 12) {
        if (y === 1 || (y === 3 && (x === 8 || x === 12))) {
          tiles[y][x] = { type: TileType.WALL, walkable: false };
        } else if (y === 2 && x === 10) {
          tiles[y][x] = { type: TileType.PORTAL, walkable: true, interactable: true, interactionId: 'portal_battle' };
        } else {
          tiles[y][x] = { type: TileType.STONE, walkable: true };
        }
      }
      // çŸ³å¤´è·¯
      else if ((y === 7 && x >= 3 && x <= 17) || (x === 10 && y >= 3 && y <= 12)) {
        tiles[y][x] = { type: TileType.STONE, walkable: true };
      }
      // æ ‘æœ¨è£…é¥°
      else if ((x === 3 || x === 17) && (y === 3 || y === 11)) {
        tiles[y][x] = { type: TileType.TREE, walkable: false };
      }
      // æ°´æ± 
      else if (x >= 2 && x <= 4 && y >= 9 && y <= 11) {
        tiles[y][x] = { type: TileType.WATER, walkable: false };
      }
      // é»˜è®¤è‰åœ°
      else {
        tiles[y][x] = { type: TileType.GRASS, walkable: true };
      }
    }
  }
  
  return tiles;
}

// å¯¼å‡ºæ€ªç‰©ä¿¡æ¯ç±»å‹ä¾›å…¶ä»–ç»„ä»¶ä½¿ç”¨
export interface MapMonsterInfo {
  id: string;
  name: string;
  sprite: string;
  level: number;
}

interface WorldMapProps {
  playerName: string;
  playerId: string;
  playerSprite?: string;
  socket: Socket;
  onEnterBattle?: () => void;
  onOpenShop?: () => void;
  onMonsterEncounter?: (monster: MapMonsterInfo) => void;
}

export const WorldMap: React.FC<WorldMapProps> = ({
  playerName,
  playerId,
  playerSprite = 'ğŸ§‘',
  socket,
  onEnterBattle,
  onOpenShop,
  onMonsterEncounter,
}) => {
  const [map] = useState<GameMap>(SHELTER_MAP);
  const [playerPos, setPlayerPos] = useState<Position>(map.spawnPoint);
  const [playerDir, setPlayerDir] = useState<Direction>('down');
  const [isMoving, setIsMoving] = useState(false);
  const [showDialog, setShowDialog] = useState<{ npc: MapNPC; index: number } | null>(null);
  const [showInteraction, setShowInteraction] = useState<string | null>(null);
  const [otherPlayers, setOtherPlayers] = useState<WorldPlayer[]>([]);
  
  // ç©å®¶äº’åŠ¨ç›¸å…³çŠ¶æ€
  const [selectedPlayer, setSelectedPlayer] = useState<WorldPlayer | null>(null);
  const [showPlayerMenu, setShowPlayerMenu] = useState(false);
  const [showChatDialog, setShowChatDialog] = useState(false);
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [chatInput, setChatInput] = useState('');
  const [chatTargetPlayer, setChatTargetPlayer] = useState<WorldPlayer | null>(null);
  const [pendingInvites, setPendingInvites] = useState<PendingInvite[]>([]);
  const chatInputRef = useRef<HTMLInputElement>(null);

  // åŠ å…¥ä¸–ç•Œåœ°å›¾å¹¶ç›‘å¬å…¶ä»–ç©å®¶
  useEffect(() => {
    // åŠ å…¥ä¸–ç•Œåœ°å›¾
    socket.emit('world:join', {
      mapId: map.id,
      position: map.spawnPoint,
      direction: 'down',
      sprite: playerSprite,
    });

    // ç›‘å¬ä¸–ç•Œåœ°å›¾äº‹ä»¶
    const handlePlayers = (data: { players: WorldPlayer[] }) => {
      // è¿‡æ»¤æ‰è‡ªå·±
      setOtherPlayers(data.players.filter(p => p.id !== playerId));
    };

    const handlePlayerJoined = (data: { player: WorldPlayer }) => {
      if (data.player.id !== playerId) {
        setOtherPlayers(prev => [...prev, data.player]);
      }
    };

    const handlePlayerLeft = (data: { playerId: string }) => {
      setOtherPlayers(prev => prev.filter(p => p.id !== data.playerId));
    };

    const handlePlayerMoved = (data: { playerId: string; position: Position; direction: Direction }) => {
      setOtherPlayers(prev => prev.map(p => 
        p.id === data.playerId 
          ? { ...p, position: data.position, direction: data.direction }
          : p
      ));
    };

    // ç›‘å¬ç§èŠæ¶ˆæ¯
    const handlePrivateMessage = (data: { senderId: string; senderName: string; message: string; timestamp: Date }) => {
      setChatMessages(prev => [...prev, {
        type: 'received',
        senderName: data.senderName,
        message: data.message,
        timestamp: new Date(data.timestamp)
      }]);
      // è‡ªåŠ¨æ‰“å¼€èŠå¤©çª—å£
      const sender = otherPlayers.find(p => p.id === data.senderId);
      if (sender) {
        setChatTargetPlayer(sender);
        setShowChatDialog(true);
      }
    };

    const handlePrivateMessageSent = (data: { receiverId: string; receiverName: string; message: string; timestamp: Date }) => {
      setChatMessages(prev => [...prev, {
        type: 'sent',
        senderName: playerName,
        receiverName: data.receiverName,
        message: data.message,
        timestamp: new Date(data.timestamp)
      }]);
    };

    // ç›‘å¬ç»„é˜Ÿé‚€è¯·
    const handleTeamInvite = (data: { inviteId: string; inviterId: string; inviterName: string }) => {
      setPendingInvites(prev => [...prev, {
        inviteId: data.inviteId,
        inviterName: data.inviterName
      }]);
    };

    const handleInviteSent = (data: { targetId: string; targetName: string }) => {
      setShowInteraction(`å·²å‘ ${data.targetName} å‘é€ç»„é˜Ÿé‚€è¯·`);
      setTimeout(() => setShowInteraction(null), 2000);
    };

    const handleInviteAccepted = (data: { playerId: string; playerName: string }) => {
      setShowInteraction(`${data.playerName} æ¥å—äº†ä½ çš„ç»„é˜Ÿé‚€è¯·ï¼`);
      setTimeout(() => setShowInteraction(null), 2000);
    };

    const handleInviteDeclined = (data: { playerId: string; playerName: string }) => {
      setShowInteraction(`${data.playerName} æ‹’ç»äº†ä½ çš„ç»„é˜Ÿé‚€è¯·`);
      setTimeout(() => setShowInteraction(null), 2000);
    };

    const handleInviteError = (data: { message: string }) => {
      setShowInteraction(`é‚€è¯·å¤±è´¥: ${data.message}`);
      setTimeout(() => setShowInteraction(null), 2000);
    };

    socket.on('world:players', handlePlayers);
    socket.on('world:playerJoined', handlePlayerJoined);
    socket.on('world:playerLeft', handlePlayerLeft);
    socket.on('world:playerMoved', handlePlayerMoved);
    socket.on('chat:privateMessage', handlePrivateMessage);
    socket.on('chat:privateMessageSent', handlePrivateMessageSent);
    socket.on('team:inviteReceived', handleTeamInvite);
    socket.on('team:inviteSent', handleInviteSent);
    socket.on('team:inviteAccepted', handleInviteAccepted);
    socket.on('team:inviteDeclined', handleInviteDeclined);
    socket.on('team:inviteError', handleInviteError);

    return () => {
      socket.emit('world:leave');
      socket.off('world:players', handlePlayers);
      socket.off('world:playerJoined', handlePlayerJoined);
      socket.off('world:playerLeft', handlePlayerLeft);
      socket.off('world:playerMoved', handlePlayerMoved);
      socket.off('chat:privateMessage', handlePrivateMessage);
      socket.off('chat:privateMessageSent', handlePrivateMessageSent);
      socket.off('team:inviteReceived', handleTeamInvite);
      socket.off('team:inviteSent', handleInviteSent);
      socket.off('team:inviteAccepted', handleInviteAccepted);
      socket.off('team:inviteDeclined', handleInviteDeclined);
      socket.off('team:inviteError', handleInviteError);
    };
  }, [socket, map.id, map.spawnPoint, playerId, playerSprite, playerName, otherPlayers]);

  // æ£€æŸ¥ä½ç½®æ˜¯å¦å¯é€šè¡Œ
  const canMoveTo = useCallback((pos: Position): boolean => {
    if (pos.x < 0 || pos.x >= map.width || pos.y < 0 || pos.y >= map.height) {
      return false;
    }
    const tile = map.tiles[pos.y][pos.x];
    return tile.walkable;
  }, [map]);

  // è·å–ä½ç½®ä¸Šçš„å®ä½“
  const getEntityAt = useCallback((pos: Position) => {
    const npc = map.npcs.find(n => n.position.x === pos.x && n.position.y === pos.y);
    const monster = map.monsters.find(m => m.position.x === pos.x && m.position.y === pos.y);
    const portal = map.portals.find(p => p.position.x === pos.x && p.position.y === pos.y);
    return { npc, monster, portal };
  }, [map]);

  // ç§»åŠ¨ç©å®¶
  const movePlayer = useCallback((direction: Direction) => {
    if (isMoving) return;

    setPlayerDir(direction);
    const delta = DIRECTION_DELTA[direction];
    const newPos = {
      x: playerPos.x + delta.x,
      y: playerPos.y + delta.y,
    };

    if (canMoveTo(newPos)) {
      setIsMoving(true);
      setPlayerPos(newPos);
      
      // é€šçŸ¥æœåŠ¡å™¨ç©å®¶ç§»åŠ¨
      socket.emit('world:move', {
        position: newPos,
        direction,
      });
      
      // æ£€æŸ¥æ–°ä½ç½®ä¸Šçš„å®ä½“
      const entity = getEntityAt(newPos);
      
      if (entity.portal) {
        setShowInteraction(`ä¼ é€åˆ°: ${entity.portal.name}`);
        setTimeout(() => setShowInteraction(null), 1500);
      }
      
      // æ£€æŸ¥æ˜¯å¦ä¸æ€ªç‰©ä½ç½®é‡å ï¼ˆéBOSSæ€ªç‰©è§¦å‘æˆ˜æ–—ï¼‰
      if (entity.monster && !entity.monster.isBoss) {
        setShowInteraction(`é­é‡ ${entity.monster.name}ï¼`);
        setTimeout(() => {
          setShowInteraction(null);
          // è§¦å‘æ€ªç‰©æˆ˜æ–—
          if (onMonsterEncounter) {
            onMonsterEncounter({
              id: entity.monster!.id,
              name: entity.monster!.name,
              sprite: entity.monster!.sprite,
              level: entity.monster!.level,
            });
          }
        }, 500);
      }
      
      setTimeout(() => setIsMoving(false), 150);
    }
  }, [playerPos, canMoveTo, getEntityAt, isMoving, socket, onMonsterEncounter]);

  // äº¤äº’
  const interact = useCallback(() => {
    // æ£€æŸ¥é¢å‰çš„ä½ç½®
    const delta = DIRECTION_DELTA[playerDir];
    const frontPos = {
      x: playerPos.x + delta.x,
      y: playerPos.y + delta.y,
    };
    
    const { npc, monster, portal } = getEntityAt(frontPos);
    
    if (npc) {
      setShowDialog({ npc, index: 0 });
    } else if (monster) {
      if (monster.isBoss) {
        setShowInteraction(`æŒ‘æˆ˜ ${monster.name}ï¼`);
        setTimeout(() => {
          setShowInteraction(null);
          onEnterBattle?.();
        }, 1000);
      }
    } else if (portal) {
      setShowInteraction(`ä¼ é€åˆ° ${portal.name}...`);
      setTimeout(() => {
        setShowInteraction(null);
        onEnterBattle?.();
      }, 1000);
    }
    
    // ä¹Ÿæ£€æŸ¥å½“å‰ä½ç½®
    const currentEntity = getEntityAt(playerPos);
    if (currentEntity.portal) {
      setShowInteraction(`ä¼ é€åˆ° ${currentEntity.portal.name}...`);
      setTimeout(() => {
        setShowInteraction(null);
        onEnterBattle?.();
      }, 1000);
    }
  }, [playerPos, playerDir, getEntityAt, onEnterBattle]);

  // ç‚¹å‡»å…¶ä»–ç©å®¶æ˜¾ç¤ºäº’åŠ¨èœå•
  const handlePlayerClick = useCallback((player: WorldPlayer, e: React.MouseEvent) => {
    e.stopPropagation();
    setSelectedPlayer(player);
    setShowPlayerMenu(true);
  }, []);

  // å…³é—­ç©å®¶äº’åŠ¨èœå•
  const closePlayerMenu = useCallback(() => {
    setShowPlayerMenu(false);
    setSelectedPlayer(null);
  }, []);

  // é‚€è¯·ç»„é˜Ÿ
  const inviteToTeam = useCallback(() => {
    if (selectedPlayer) {
      socket.emit('team:invite', { targetId: selectedPlayer.id });
      closePlayerMenu();
    }
  }, [selectedPlayer, socket, closePlayerMenu]);

  // æ‰“å¼€ç§èŠ
  const openPrivateChat = useCallback(() => {
    if (selectedPlayer) {
      setChatTargetPlayer(selectedPlayer);
      setShowChatDialog(true);
      closePlayerMenu();
      // èšç„¦è¾“å…¥æ¡†
      setTimeout(() => chatInputRef.current?.focus(), 100);
    }
  }, [selectedPlayer, closePlayerMenu]);

  // å‘é€ç§èŠæ¶ˆæ¯
  const sendPrivateMessage = useCallback(() => {
    if (chatTargetPlayer && chatInput.trim()) {
      socket.emit('chat:sendPrivate', {
        targetId: chatTargetPlayer.id,
        message: chatInput.trim()
      });
      setChatInput('');
    }
  }, [chatTargetPlayer, chatInput, socket]);

  // å…³é—­ç§èŠ
  const closeChat = useCallback(() => {
    setShowChatDialog(false);
    setChatTargetPlayer(null);
  }, []);

  // æ¥å—ç»„é˜Ÿé‚€è¯·
  const acceptInvite = useCallback((inviteId: string) => {
    socket.emit('team:acceptInvite', { inviteId });
    setPendingInvites(prev => prev.filter(i => i.inviteId !== inviteId));
  }, [socket]);

  // æ‹’ç»ç»„é˜Ÿé‚€è¯·
  const declineInvite = useCallback((inviteId: string) => {
    socket.emit('team:declineInvite', { inviteId });
    setPendingInvites(prev => prev.filter(i => i.inviteId !== inviteId));
  }, [socket]);

  // é”®ç›˜æ§åˆ¶
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // å¦‚æœæ­£åœ¨å¯¹è¯ï¼Œå¤„ç†å¯¹è¯é€»è¾‘
      if (showDialog) {
        if (e.key === ' ' || e.key === 'Enter' || e.key === 'z') {
          e.preventDefault();
          if (showDialog.index < showDialog.npc.dialogues.length - 1) {
            setShowDialog({ ...showDialog, index: showDialog.index + 1 });
          } else {
            setShowDialog(null);
            // å¦‚æœæ˜¯å•†äººï¼Œæ‰“å¼€å•†åº—
            if (showDialog.npc.type === 'shop') {
              onOpenShop?.();
            }
          }
        }
        return;
      }

      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          e.preventDefault();
          movePlayer('up');
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          e.preventDefault();
          movePlayer('down');
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          e.preventDefault();
          movePlayer('left');
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          e.preventDefault();
          movePlayer('right');
          break;
        case ' ':
        case 'Enter':
        case 'z':
        case 'Z':
          e.preventDefault();
          interact();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [movePlayer, interact, showDialog, onOpenShop]);

  // æ¸²æŸ“ç“·ç –
  const renderTile = (tile: GameMap['tiles'][0][0], x: number, y: number) => {
    const visual = TILE_VISUALS[tile.type];
    const isPlayerHere = playerPos.x === x && playerPos.y === y;
    
    // æ£€æŸ¥å®ä½“
    const npc = map.npcs.find(n => n.position.x === x && n.position.y === y);
    const monster = map.monsters.find(m => m.position.x === x && m.position.y === y);
    
    // æ£€æŸ¥å…¶ä»–ç©å®¶
    const otherPlayerHere = otherPlayers.find(p => p.position.x === x && p.position.y === y);
    
    return (
      <div
        key={`${x}-${y}`}
        className={`map-tile ${tile.type} ${tile.interactable ? 'interactable' : ''}`}
        style={{
          backgroundColor: visual.bgColor,
          color: visual.color,
        }}
      >
        {/* åœ°é¢å±‚ */}
        <span className="tile-char">{visual.char}</span>
        
        {/* NPCå±‚ */}
        {npc && !isPlayerHere && !otherPlayerHere && (
          <span className="entity-sprite npc animate-float">{npc.sprite}</span>
        )}
        
        {/* æ€ªç‰©å±‚ */}
        {monster && !isPlayerHere && !otherPlayerHere && (
          <span className={`entity-sprite monster ${monster.isBoss ? 'boss animate-float' : ''}`}>
            {monster.sprite}
          </span>
        )}
        
        {/* å…¶ä»–ç©å®¶å±‚ */}
        {otherPlayerHere && !isPlayerHere && (
          <div 
            className="other-player-container clickable"
            onClick={(e) => handlePlayerClick(otherPlayerHere, e)}
            title={`ç‚¹å‡»ä¸ ${otherPlayerHere.username} äº’åŠ¨`}
          >
            <span className={`player-sprite other-player dir-${otherPlayerHere.direction}`}>
              {otherPlayerHere.sprite}
            </span>
            <span className="player-name-tag pixel-text-xs">{otherPlayerHere.username}</span>
          </div>
        )}
        
        {/* ç©å®¶å±‚ */}
        {isPlayerHere && (
          <span className={`player-sprite dir-${playerDir} ${isMoving ? 'moving' : ''}`}>
            {playerSprite}
          </span>
        )}
      </div>
    );
  };

  return (
    <div className="pixel-world-screen">
      {/* é¡¶éƒ¨ä¿¡æ¯æ  */}
      <div className="world-header pixel-panel">
        <div className="location-info">
          <span className="location-icon">ğŸ“</span>
          <span className="pixel-text">{map.name}</span>
        </div>
        <div className="online-players-info">
          <span className="online-icon">ğŸ‘¥</span>
          <span className="pixel-text-small">{otherPlayers.length + 1} åœ¨çº¿</span>
        </div>
        <div className="player-info-mini">
          <span>{playerSprite} {playerName}</span>
        </div>
      </div>

      {/* åœ°å›¾åŒºåŸŸ */}
      <div className="world-map-container">
        <div 
          className="world-map pixel-panel"
          style={{
            gridTemplateColumns: `repeat(${map.width}, 32px)`,
            gridTemplateRows: `repeat(${map.height}, 32px)`,
          }}
        >
          {map.tiles.map((row, y) =>
            row.map((tile, x) => renderTile(tile, x, y))
          )}
        </div>
      </div>

      {/* æ§åˆ¶æç¤º */}
      <div className="control-hints pixel-panel pixel-panel-dark">
        <div className="hint-row">
          <span className="pixel-badge">W A S D</span>
          <span className="pixel-text-small">ç§»åŠ¨</span>
        </div>
        <div className="hint-row">
          <span className="pixel-badge">ç©ºæ ¼/Z</span>
          <span className="pixel-text-small">äº¤äº’</span>
        </div>
      </div>

      {/* ç§»åŠ¨æ§åˆ¶å™¨ï¼ˆç§»åŠ¨ç«¯ï¼‰ */}
      <div className="mobile-controls">
        <button className="ctrl-btn up" onClick={() => movePlayer('up')}>â–²</button>
        <div className="ctrl-row">
          <button className="ctrl-btn left" onClick={() => movePlayer('left')}>â—„</button>
          <button className="ctrl-btn action" onClick={interact}>â—‹</button>
          <button className="ctrl-btn right" onClick={() => movePlayer('right')}>â–º</button>
        </div>
        <button className="ctrl-btn down" onClick={() => movePlayer('down')}>â–¼</button>
      </div>

      {/* å¯¹è¯æ¡† */}
      {showDialog && (
        <div className="pixel-dialog-box">
          <div className="dialog-speaker">
            <span className="speaker-sprite">{showDialog.npc.sprite}</span>
            <span className="speaker-name pixel-text">{showDialog.npc.name}</span>
          </div>
          <div className="dialog-content pixel-text">
            {showDialog.npc.dialogues[showDialog.index]}
          </div>
          <div className="dialog-hint pixel-text-small animate-blink">
            æŒ‰ ç©ºæ ¼/Z ç»§ç»­...
          </div>
        </div>
      )}

      {/* äº¤äº’æç¤º */}
      {showInteraction && (
        <div className="interaction-toast pixel-panel">
          <span className="pixel-text">{showInteraction}</span>
        </div>
      )}

      {/* ç©å®¶äº’åŠ¨èœå• */}
      {showPlayerMenu && selectedPlayer && (
        <div className="player-menu-overlay" onClick={closePlayerMenu}>
          <div className="player-menu pixel-panel" onClick={(e) => e.stopPropagation()}>
            <div className="player-menu-header">
              <span className="player-menu-sprite">{selectedPlayer.sprite}</span>
              <span className="player-menu-name pixel-text">{selectedPlayer.username}</span>
            </div>
            <div className="player-menu-actions">
              <button 
                className="player-menu-btn pixel-btn" 
                onClick={inviteToTeam}
              >
                <span className="btn-icon">ğŸ¤</span>
                <span>é‚€è¯·ç»„é˜Ÿ</span>
              </button>
              <button 
                className="player-menu-btn pixel-btn" 
                onClick={openPrivateChat}
              >
                <span className="btn-icon">ğŸ’¬</span>
                <span>ç§èŠ</span>
              </button>
            </div>
            <button className="player-menu-close pixel-btn-small" onClick={closePlayerMenu}>
              å…³é—­
            </button>
          </div>
        </div>
      )}

      {/* ç§èŠå¯¹è¯æ¡† */}
      {showChatDialog && chatTargetPlayer && (
        <div className="chat-dialog-overlay">
          <div className="chat-dialog pixel-panel">
            <div className="chat-dialog-header">
              <span className="chat-target-sprite">{chatTargetPlayer.sprite}</span>
              <span className="chat-target-name pixel-text">ä¸ {chatTargetPlayer.username} ç§èŠ</span>
              <button className="chat-close-btn" onClick={closeChat}>âœ•</button>
            </div>
            <div className="chat-messages">
              {chatMessages
                .filter(msg => 
                  (msg.type === 'sent' && msg.receiverName === chatTargetPlayer.username) ||
                  (msg.type === 'received' && msg.senderName === chatTargetPlayer.username)
                )
                .map((msg, index) => (
                  <div key={index} className={`chat-message ${msg.type}`}>
                    <span className="chat-sender">{msg.type === 'sent' ? 'æˆ‘' : msg.senderName}:</span>
                    <span className="chat-content">{msg.message}</span>
                  </div>
                ))
              }
            </div>
            <div className="chat-input-area">
              <input
                ref={chatInputRef}
                type="text"
                className="chat-input pixel-input"
                placeholder="è¾“å…¥æ¶ˆæ¯..."
                value={chatInput}
                onChange={(e) => setChatInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    sendPrivateMessage();
                  }
                }}
              />
              <button className="chat-send-btn pixel-btn" onClick={sendPrivateMessage}>
                å‘é€
              </button>
            </div>
          </div>
        </div>
      )}

      {/* ç»„é˜Ÿé‚€è¯·é€šçŸ¥ */}
      {pendingInvites.length > 0 && (
        <div className="team-invites-container">
          {pendingInvites.map((invite) => (
            <div key={invite.inviteId} className="team-invite pixel-panel">
              <div className="invite-content">
                <span className="invite-icon">ğŸ¤</span>
                <span className="pixel-text-small">{invite.inviterName} é‚€è¯·ä½ ç»„é˜Ÿ</span>
              </div>
              <div className="invite-actions">
                <button 
                  className="invite-btn accept pixel-btn-small" 
                  onClick={() => acceptInvite(invite.inviteId)}
                >
                  æ¥å—
                </button>
                <button 
                  className="invite-btn decline pixel-btn-small" 
                  onClick={() => declineInvite(invite.inviteId)}
                >
                  æ‹’ç»
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
